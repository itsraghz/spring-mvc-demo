package com.raghsonline.phonebook.repository.impl;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.apache.log4j.Logger;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import com.raghsonline.phonebook.model.Contact;
import com.raghsonline.phonebook.repository.DAO;

@Repository
public class ContactDAO implements DAO<Contact> 
{
	Logger logger = Logger.getLogger(ContactDAO.class);
	
	/**
	 * <p>
	 * An injectable dependency of the <tt>JdbcTemplate</tt>, 
	 * will be <tt>@Autowired</tt> by the Spring Container.
	 * </p>
	 */
	private JdbcTemplate jdbcTemplate;
	
	/**
	 * @param jdbcTemplate
	 */
	public ContactDAO(JdbcTemplate jdbcTemplate) 
	{
		super();
		logger.info("ContactDAO() instantiated, jdbcTemplate=" + jdbcTemplate);
		this.setJdbcTemplate(jdbcTemplate);
	}
	
	public void cleanup()
	{
		//dropTable();
		createTable();// (IF NOT EXISTS clause is added in the DDL Statement)
        getCount();
	}
	
	public void reset()
	{
        //truncateTable();
        getCount();
	}
	
	public void dropTable()
    {
        logger.info("dropTable() invoked");
        
        String sql = "DROP TABLE Contact";
        
        jdbcTemplate.execute(sql);
        
        logger.info("An attempt to drop the Table Contact was completed");
    }
	
	public void createTable()
    {
        logger.info("createTable() invoked");
        
        String sql = "CREATE TABLE IF NOT EXISTS Contact\n"
                    + "(\n"
                    + "     Id INT auto_increment primary key,\n"
                    + "     FirstName VARCHAR(30) NOT NULL,\n"
                    + "     LastName VARCHAR(30) NOT NULL,\n"
                    + "     DOB VARCHAR(20),\n"
                    + "     ContactNo VARCHAR(10) UNIQUE NOT NULL,\n"
                    + "     EMAIL VARCHAR(30),\n"
                    + "     NOTES VARCHAR(50),\n"
                    + "     TAG VARCHAR(50)\n"
                    + ")";
        
        jdbcTemplate.execute(sql);
        
        logger.info("An attempt to create the Table Contact was completed");
    }
	
	public void truncateTable()
    {
        logger.info("truncateTable() invoked");
        
        String sql = "TRUNCATE Contact";
        
        jdbcTemplate.execute(sql);
        
        logger.info("An attempt to truncate the Table Contact was completed");
    }
	
	@Override
    public long getCount()
    {
        logger.info("getCount() invoked ");
        
        long count = 0;
        
        logger.info("getCount() invoked");
        
        String sql = "SELECT COUNT(*) from Contact";
        
        count = jdbcTemplate.queryForObject(sql, Long.class);
        
        logger.info("Count : " + count);
        
        return count;
    }
	

	@Override
	public long create(Contact t) 
	{
		long generatedKey = 0;
		
		//generatedKey = createAndReturnAffectedRows(t);
		generatedKey = createAndReturnGeneratedKey(t);
		
		return generatedKey;
	}
	
	/**
	 * <p>
	 * A method to create a new Contact and return the autogenerated
	 * Sequence value (<b>Primary Key</b>).
	 * </p>
	 * <p>
	 * <b>Solution: </b> Spring has a different Interface called `KeyHolder`
	 * with the implementation class 'GeneratedKeyHolder' which indeed
	 * needs to be passed while executing (but NOT along with this
	 * update method) to get back the autogenerated values stuffed in it.
	 * 
	 * It is more like an OUT parameter in the Stored Procedure.
	 * IN - for the input values what we pass from our Program to the Database
	 * OUT - to hold the values what we expect from the Database back to the Program.
	 *
	 * </p>
	 * @param t the contact instance to be created
	 * @return long the number of rows affected
	 */
	private long createAndReturnGeneratedKey(Contact t) 
	{	
		logger.info("create(Contact) invoked, contact :" + t);
		
		String sql = "INSERT INTO Contact"
				+ "(FirstName, LastName, Dob, ContactNo, Email, Notes, Tag) "
				+ "VALUES (?, ?, ?, ?, ?, ?, ?)";
		
		long generatedKey = 0;
		
		KeyHolder keyHolder = new GeneratedKeyHolder();
		
		/* Here we should actually use a different version of the update() method
		 * that takes a PreparedStatement and a KeyHolder, but still it returns
		 * the rowsAffected as an int value
		 */
		int rowsAffected = jdbcTemplate.update(connection -> {
				/* the 2nd parameter must specify the list of column Names which is an autogenerated column! */
				PreparedStatement ps = connection.prepareStatement(sql, new String[] {"Id"});
				
				/* We need to bind the actual values to the ? placeholders with the right index */
				/** Note: PS Index always starts with 1 and NOT 0 (like Arrays, Collections) */
				ps.setString(1, t.getFirstName());
				ps.setString(2, t.getLastName());
				ps.setString(3, t.getDob());
				ps.setString(4, t.getContactNo());
				ps.setString(5, t.getEmail());
				ps.setString(6, t.getNotes());
				ps.setString(7, t.getTag());
				
				/* 
				 * We are returning the ps to the update method, that indeed expects a PreparedStatementCreator 
				 * as the first argument, and the 2nd arg is the keyHolder.
				 */
				return ps;
			}, keyHolder);
		
		// Always expected to be 1 as in this case we insert just 1 record.
		logger.info("rowsAffected : " + rowsAffected);
		
		/* How do we actually get the auto generated key value in our Program? */
		generatedKey = keyHolder.getKey().longValue();
		
		logger.info("generatedKey :: " + generatedKey);
		
		return generatedKey;
	}
	
	/**
	 * <p>
	 * A method to execute a DML (for Create Contact) and return the affected rows, 
	 * </p>
	 * <p>
	 * <b>Problem: </b> The `jdbcTemplate.update()` method returns
	 * the number of rows affected after executing the DML statement
	 * (Insert, Update, Delete) which will certainly NOT be equal 
	 * to the autogenerated Sequence Value - PK.
	 * </p>
	 * @param t the contact instance to be created
	 * @return long the number of rows affected
	 */
	@SuppressWarnings("unused") //NOT Recommended as otherwise you would not have a clue on the unused methods in a Class.
	private long createAndReturnAffectedRows(Contact t) 
	{	
		logger.info("create(Contact) invoked, contact :" + t);
		
		String sql = "INSERT INTO Contact"
				+ "(FirstName, LastName, Dob, ContactNo, Email, Notes, Tag) "
				+ "VALUES (?, ?, ?, ?, ?, ?, ?)";
		
		long rowsAffected = jdbcTemplate.update(sql, 
				t.getFirstName(), t.getLastName(), t.getDob(), 
				t.getContactNo(), t.getEmail(), t.getNotes(), t.getTag());
		
		logger.info("rowsAffected : " + rowsAffected);
		
		return rowsAffected;
	}
	

	@Override
	public Optional<Contact> getByContactNo(String contactNo) 
	{
		logger.info("getByContactNo() invoked, contactNo=" + contactNo);
		
		Optional<Contact> optionalContact = Optional.empty();
		
		long count = getCount();
		logger.info("Count :: " + count);
		
		if(count <= 0)
		{
			logger.info("count is <= 0, does NOT make any sense to query the table further");
			return optionalContact;
		} 
		
		optionalContact = getByContactNoUsingPS(contactNo);
		//optionalContact = getByContactNoUsingStmt(contactNo);
		
		logger.info("OptionalContact :: " + optionalContact);
		
		return optionalContact;
	}
	
	public Optional<Contact> getByContactNoUsingStmt(String contactNo) 
	{
		logger.info("getByContactNoUsingSmt() invoked, contactNo=" + contactNo);
		
		/* Uses a Statement , appending the value to the Stmt directly */
		String sql = "SELECT * FROM CONTACT WHERE ContactNo = " + contactNo;
		
		Contact contact = null;

		/* 
		 * We can use the simplest version of queryForObject() method, 
		 * as there is NO need of binding any arguments
		 */
		//contact = jdbcTemplate.queryForObject(sql, Contact.class);
		
		contact = jdbcTemplate.query(sql, rs -> {
			logger.info("resultset : " + rs);
			
			if(null==rs) return null;
			
			rs.next();
			
			Contact c = new Contact();
			
			c.setFirstName(rs.getString("FirstName"));
			c.setLastName(rs.getString("LastName"));
			c.setDob(rs.getString("Dob"));
			c.setContactNo(rs.getString("ContactNo"));
			c.setEmail(rs.getString("Email"));
			c.setNotes(rs.getString("Notes"));
			c.setTag(rs.getString("Tag"));
			
			logger.info("contact object c about to be returned : " + c);
			
			return c;
		}); 
				
		logger.info("contact obj from jdbcTemplate : " + contact);
		
		return (null!=contact) ? Optional.of(contact) : Optional.empty();
	}
	
	public Optional<Contact> getByContactNoUsingPS(String contactNo) 
	{
		logger.info("getByContactNoUsingPS() invoked, contactNo=" + contactNo);
		
		/* Uses a PreparedStatement */
		String sql = "SELECT * FROM CONTACT WHERE ContactNo = ?";
		
		/*Contact contact = jdbcTemplate.queryForObject(sql,new Object[] {contactNo}, 
				(rs, rowNum) -> {return contactRowMapper(rs);} );
			logger.info("contact obj from jdbcTemplate : " + contact);
			return (null!=contact) ? Optional.of(contact) : Optional.empty();
		*/

		/** 
		 * Because we have an error with the queryForObject() that expects a min of 1 row
		 * (requiresSingleResultset) (no less, no more) and in case there are no matching
		 * records for the duplicate (which we check before adding a new contact 
		 * for the duplicates if any), it throws an exception (<tt>EmptyResultDataAccessException</tt>, 
		 * which is indeed a sub class of <tt>DataAccessException</tt>).
		 * 
		 * As the Spring framework covers this exception under the hood, and does not cascade
		 * it back to the caller (our method below), we have NO way to control the exception, 
		 * and hence it blows up and stops the execution.
		 * 
		 * Hence we catch the exception and log it and ignore it, as it is a known case, 
		 * though it is not a generally recommended practice.
		 */
		try {
			return jdbcTemplate.queryForObject(sql, new Object[] {contactNo}, 
				(rs, rowNum) -> Optional.of(contactRowMapper(rs)));
		}catch(EmptyResultDataAccessException empDataAccessException) {
			logger.info("No matching records available in the database for the contactNo - " + contactNo);
			return Optional.empty();
		}
	}

	private Contact contactRowMapper(ResultSet rs) throws SQLException 
	{
		Contact c = new Contact();
		
		c.setId(rs.getInt("Id"));
		c.setFirstName(rs.getString("FirstName"));
		c.setLastName(rs.getString("LastName"));
		c.setDob(rs.getString("Dob"));
		c.setContactNo(rs.getString("ContactNo"));
		c.setEmail(rs.getString("Email"));
		c.setNotes(rs.getString("Notes"));
		c.setTag(rs.getString("Tag"));
		
		return c;
	}
	
	@Override
	public Optional<Contact> getById(int id) 
	{
		logger.info("getById() invoked, id=" + id);
		
		String sql = "SELECT * FROM CONTACT WHERE Id=?";
		
		Contact contact = jdbcTemplate.query(sql, new Object[] {id}, rs -> {
			rs.next();
			return contactRowMapper(rs);
		});
		
		logger.info("contact :: " + contact);
		
		Optional<Contact> optionalContact = null!=contact? Optional.of(contact) : Optional.empty();
		
		return optionalContact;
	}

	@Override
	public long update(Contact t)
	{
		logger.info("updateContact Invoked() - " + t);
		
		String sql = "UPDATE CONTACT SET FirstName =?,LastName =?,DOB =?,ContactNo=?,EMAIL=?,NOTES=?,TAG=?"
				   + "WHERE Id = ?";
		logger.info("SQL Query :" + sql);
		

		long rowsAffected = jdbcTemplate.update(sql, 
				t.getFirstName(), t.getLastName(), t.getDob(), 
				t.getContactNo(), t.getEmail(), t.getNotes(), t.getTag(),t.getId());
		
		logger.info("rowsAffected : " + rowsAffected);
		
		return rowsAffected;
	}

	@Override
	public long deleteById(int id) 
	{
		logger.info("deleteById - Invoked");
		String sql = "DELETE FROM CONTACT WHERE Id = ?";
		logger.info("SQL Query :" + sql);
		
		long rowsAffected = jdbcTemplate.update(sql,id);
		
		return rowsAffected;
	}

	@Override
	public boolean delete(Contact t) {
		// TODO Auto-generated method stub
		return false;
	}


	public JdbcTemplate getJdbcTemplate() {
		return jdbcTemplate;
	}


	public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Override
	public List<Contact> getAll() 
	{
		logger.info("getAll() invoked");
		
		String sql = "SELECT * FROM CONTACT";
		
		List<Contact> contactList = new ArrayList<>();
		
		contactList =  jdbcTemplate.query(sql, (rs, rowNum) -> {
			return contactRowMapper(rs);
		});
		
		logger.info("contactList :: " + contactList);
		
		return contactList;
	}

}
